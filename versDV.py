# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U4ik8hB0K_OjBCmE-1_z04khr1NvKBCF
"""

import numpy as np
import matplotlib.pyplot as plt
from math import *

def normale(theta,phi):
    # retourne le vecteur unitaire définit par (cos(theta)*sin(phi),sin(theta)*sin(phi),cos(phi))
    vN = [cos(theta)*sin(phi),sin(theta)*sin(phi),cos(phi)]
    return vN

def tens_to_mat(liste):
    res = []
    if len(liste) == 6 :
        ligne1 = [liste[0],liste[3],liste[4]]
        ligne2 = [liste[3],liste[1],liste[5]]
        ligne3 = [liste[4],liste[5],liste[2]]
    res.append(ligne1)
    res.append(ligne2)
    res.append(ligne3)
    return res

def contTang(tens,vN):
    # calcul le vecteur contrainte tangentiell sur une facette de normale vN
    M = tens_to_mat(tens)# vecteur contrainte
    cont = np.dot(M,vN)# contrainte normale
    contT = cont.transpose()
    cN = np.dot(contT,vN)
    contT = cont-cN*vN
    return contT

def hydro(tens,instant):
    # cette fonction doit retourner la pression hydrostatique associée à ce tenseur (c'est pour un instant du cycle !)
    p = (tens[instant][0]+tens[instant][1]+tens[instant][2])/3
    return p

tens = genereTens(100,2*pi,0.01,1)
hydro(tens,0)

def genereTens(sigma1,omega,pasTemps,fin):
  tens = np.array([sigma1,0,0,0,0,0])
  for i in range(int(fin/pasTemps)):
    t = i+1 * pasTemps
    ligne = np.array([sigma1*cos(omega*t),0,0,0,0,0])
    tens = np.vstack((tens, ligne))
    # omega est la pulsation, vous pouvez choisir 2*pi par exemple
    # sigma1 est fixe, par exemple 100 MPa
    # cette fonction doit générer une matrice de 6 colonnes, chaque ligne étant le tenseur à un instant du cycle, et de la forme [sigma1*cos(omega*t),0,0,0,0,0]
  return tens

genereTens(100,2*pi,0.01,1)

def amplitudeTangMax(tens,instant):
    # cette fonction doit retourner pour UN instant une liste de deux éléments : le premier élément est la valeur max_n (norme de contTang) et le deuxième les angles du plan associés
    # il faut balayer les facette !
    maxi = 0
    theta = 0
    planMax = [0,0]
    phi = 0
    pasTheta = pi/180
    pasPhi = pi/180
    vect_norm = normale(theta,phi)
    for i in range(180+1):
        theta = i*pasTheta
        for j in range(180+1):
            phi = j*pasPhi
            # on construit le vecteur normal
            vect_norm = normale(theta,phi)
            # on calcule la contrainte tangentielle
            contT = contTang(tens[instant],vect_norm)
            # on calcule sa norme
            norme = np.linalg.norm(contT)
            # si elle est plus grande que maxi, elle devient maxi
            if norme > maxi:
                maxi = norme
                planMax = [theta,phi]
            #on actualise planMax
    # on retourne [maxi,planMax]
    return [maxi,planMax]



def nuage(sigma1,omega,pasTemps,fin):
  points = np.array([0,0])
  tensTot = genereTens(sigma1,omega,pasTemps,fin)
  for t in range(int(fin/pasTemps)):
    tens = tensTot[t]
    cisMax = amplitudeTangMax(tens,t)[0]
    hydros = hydro(tens,t)
    ligne = np.array([cisMax,hydros])
    points = np.vstack((points, ligne))
  return points

nuage(100,2*pi,0.01,1)

def traceNuage(points):
  plt.scatter(points[:, 0], points[:, 1])
  plt.xlabel("amplitude de cisaillement max")
  plt.ylabel("pression hydrostatique")
  plt.title("Nuage de points")
  plt.show()

points = np.array([[0,1],[1,2],[3,4],[8,4]])
traceNuage(points)

tens = np.array([100,0,0,0,0,0])
vN = np.array([1/sqrt(2), 1/sqrt(2),0])
resultat = contTang(tens,vN)
print(resultat)


# générer la matrice de 6 colonnes et Ntemps instants
# construire la liste des points [amplitude de cisaillement max, pression hydrostatique] (point correspondant chacun à un instant)

# utilisation de matplotlib : liste des abscisses, liste des ordonnées, puis tracé